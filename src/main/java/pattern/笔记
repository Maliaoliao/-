###从今天开始，每天学习一点点，从基础开始，每天学习一个设计模式，从原理上弄懂，运用到真实的业务常见中

####学习java设计模式来源与《软件设计模式java版》
[语法](https://www.runoob.com/markdown/md-tutorial.html)
   
   
   什么是设计模式？
   
   
    设计模式是前辈们为了解决开发过程中经常重复的场景，而设计的一整套开发模式。
    这样有利于提高代码的重复利用性，可读性，可维护性，稳健型，安全性。
   为什么要使用设计模式？
   
   
    1：提高程序开发者的思维，逻辑，设计能力。
    2：增加代码的可重复利用，可维护，可扩展，安全，稳健性能。
    3：提高代码质量
   
   怎么去用?
    
    啥地方
    
   关于设计模式的4大关键要素
   
    1.设计模式的名称是什么？
    2.解决了一个什么样的问题？
    3.具体的设计方案和思路？
    4.达到了一个什么样的效果？
    
   在学习设计模式之前，需要知道面向对象中的几个关键知识点。继承，封装，多态。以及面向对象中的设计原则
   
  
   设计原则：
   
   1.开闭原则。
   
        软件或者程序应当对扩展开放，对修改关闭。
        
        在企业开发环境中，面对需求的不断迭代变更，遵循开闭原则，让程序增加可扩展性，在每次变更内容的时候，
        将程序的颗粒度降低到最小，只需要在原有基础之上，扩展对应功能即可，提高代码高复用
        
   2.里氏替换原则。
       
        是对开闭原则的实现。使用继承时，必须保证父类拥有的全部性质在子类中仍然成立。
        
        例如：我们都知道自然界中有鸟类，大部分鸟儿都会飞，如果我们定义一个父类，父类中有飞行这个方法。然后我们
        又创建了两个子类，分别是麻雀类，鸵鸟类。但是我们同时去继承父类（鸟类）的时候，此时的鸵鸟因为不会飞翔，
        所以继承了父类的时候，就违反了里氏替换原则。
        
   3.依赖倒置原则
   
        高层模块不应该依赖低层模块，两者都应该依赖其抽象类，
        抽象类不应该依赖细节，细节应该依赖抽象
        
        例子：代码见dependencyInversion包下的
   4.单一原则
   
        一个类或者对象，规定只能包含它自己的性质，如果存在其它特性，这样就会使代码颗粒度变粗，从而影响代码的
        耦合性。所有，一个类就负责处理与之对应的逻辑。
   
   5.接口隔离原则
   
        对单一原则的具体实现，将接口的颗粒度变细，将同一个业务模块的不能处理逻辑进行拆分，在需要使用该需求的
        地方，分别实现其不同的接口即可
        
        例子：代码见interfaceIsolation包下的
   6.迪米特原则
   
        我给这个类的另外一个名称叫"不要和陌生人说话"，在设计程序的时候，如果类和类之间没有比较的联系或者关系，
        那么他们之间的联系可以通过第三方来关联。有点中介的意思
        
        例子：代码见dmitry包下的
        
   7.合成复用原则
        
        合成复用，如果要实现代码复用，首先要考虑合成/聚合，达到复用代码的效果，其次才是选择使用继承。
        
>总结：这7大原则是为了我们在开发过程中，提高代码的复用性，降低代码相互之间的耦合性，
      提高代码的可读性，可维护性，可扩展性。站在巨人的肩膀上我们可以看的更高，走的更远。
     




软件设计模式，是基于这7个开发原则的，遵循7大开发原则，可以使我们的代码`可读性`，`可维护性`，`可扩展性`。
那么就让我们开始学习软件设计模式吧。

[百度](http://baidu.com)

[变量命名](https://unbug.github.io/codelf/#%E7%9C%81%E4%BB%BD)
##单例模式
       
       单例模式是在软件开发过程中，为了避免资源重复的创建，保证数据的一致性对对象只创建一次。
       有点"办事只跑一趟的味道"

* 懒汉模式
       
       特点：当创建一个新的类的时候，我们只需要创建一次，在代码中可以判断该对象是否为空的方式来实现单例模式
       中的懒汉模式。
       
       应用场景：配置对象，数据连接池等

    ```
     public class Switch {
     
         private static volatile Switch witch = null;
         Switch(){
             System.out.println("内部方法");
         }
     
         public static synchronized Switch getSwitch(){
             //懒汉模式的体现，如果不为空的话会创建，为空的话就会返回已经创建好的对象
             if(witch == null){
                 System.out.println("空开关");
                 witch = new Switch();
                 return witch;
             }
             System.out.println("已经打开了");
             return witch;
         }
     
         public void getName(){
             System.out.println("这是一个开关");
         };
     }
      
       /**
       * Test 测试懒汉模式.
       */
      @Test
      public void testMethod() {
          Switch s = Switch.getSwitch();
          s.getName();
          Switch s2 = Switch.getSwitch();
          s2.getName();
          //如果使用new出来的对象,对象的code是不一样的。（通过debug的方式可以查看）
          Switch s3 = new Switch();
          if (s == s2) {
              System.out.println("同一个操作对象");
              return;
          }
          System.out.println("不同的操作对象");
      }
     ```
       

* 饿汉模式

        特点，在程序创建的时候，该对象就已经创建。
    ```
    public class User {
    
        /**
         * 对象在运行程序的时候就被创建出来了
         */
        private static User instance;
    
        static {
            instance = new User();
        }
        private User(){
            System.out.println("第N次进入");
        }
    
        /**
         * Get user user.
         *
         * @return the user
         */
        public static final User getUser(){
            System.out.println("进来");
            return instance;
        }
    
        /**
         * Gets name.
         */
        public void getName() {
            System.out.println("获取用户名称");
        }
    }
      //测试饿汉模式
      @Test
      public void test() {
          User u = User.getUser();
          u.getName();
  
          User u2 = User.getUser();
          u2.getName();
  
  
          if(u == u2){
              System.out.println("同一个对象");
          }
  
      }
  ```
        
##原型模式
        
        使用clone()实现对对象的克隆，这样产生的对象相对与单例模式产生的对象，它们的内存地址是不一样的。
        核心就是克隆对象,
        在对象属性相同或者相似的时候，可以克隆对象实现原型模式
    
```
    public class User implements Cloneable {
    
        /**
         * 对象在运行程序的时候就被创建出来了
         */
        private static User instance;
    
        static {
            instance = new User();
        }
        private User(){
            System.out.println("第N次进入");
        }
    
        /**
         * Get user user.
         *
         * @return the user
         */
        public static final User getUser(){
            System.out.println("进来");
            return instance;
        }
    
        /**
         * Gets name.
         */
        public void getName() {
            System.out.println("获取用户名称");
        }
    
    }
    
    @Test
        public void test() throws CloneNotSupportedException {
            User u = new User();
    
            User res = (User) u.clone();
    
            if(u == res){
                System.out.println("对象相等");
            }
    
    
            if(u == res){
                System.out.println("对象相等");
            }
            System.out.println(u.getName());
    
            System.out.println(res.getName());
    
        }
```
##工厂模式
        特点：创建与使用分离，使用者只需要关于工厂会产生的内容，而无需关注工厂的具体实现。
        代码：  factory
        一个字：妙
##建造者模式
        建造者模式
            1.抽象buile类，用来提供抽象的建造方法。
            2.抽象build实现类，用来实现具体的建造方式，包含具体的实现。
            3.指挥者类，用来协调构建buile创造类中的方法。
        代码：build
##代理模式
        解决了高级类不能被修改的问题，使用代理模式，可以实现代理高级类，从而在使用高级类的时候
        可以做一些其它业务操作。
        jdk 代理： 只能代理接口，
        静态代理 proxy.staticproxy 只代理关键类
        动态代理 proxy.dynamicproxy 需要实现InvocationHandler接口
        CGlib 代理： 类也可以代理，性能高，使用asm机制
```
//jdk代理
public class MyProxy implements InvocationHandler {

    //真实对象
    private Object objecrs = null;

    /**
     * Bind object.
     *
     * @param objecrs the objecrs
     * @return the object
     */

    public Object bind(Object objecrs){
        this.objecrs = objecrs;
        return Proxy.newProxyInstance(objecrs.getClass().getClassLoader(), objecrs.getClass().getInterfaces(), this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("1");
        //这个objecrs一定要是真实对象中的对象，否则会进入死循环
        Object object = method.invoke(objecrs,args);
        System.out.println("2");
        return object;
    }
}




    //CGlib动态代理 
    public class LogInterceptor implements MethodInterceptor {
        @Override
        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
            System.out.println("之前" + method.getName());
            //return null;
            Object res = methodProxy.invokeSuper(o, objects);
            System.out.println("之后" + method.getName());
            return res;
        }




    @Test
    public void test(){
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserDao.class);
        enhancer.setCallback(new LogInterceptor());
        UserDao user = (UserDao)enhancer.create();

        user.getUserAll("123123");
        System.out.println(user.id = "123");
    }
```

##适配器模式
        我理解的适配器就是充当了一个翻译的功能，可以将中文翻译成英文，也可以将法语翻译成英文。
        双向适配器则是一个适配器可以用作是A，B两个人之间的互相翻译，互相适配
        代码：
        多适配：adaptee.manyadaptee
        双向适配： adaptee.twowayadaptee
##桥接模式
     代码：pattern.bridging.jacket  购买不同颜色和不同品牌的服饰
     当属性有多个维度时，而且两个维度会不断纵向扩展时，我们可以使用桥接模式来实现，
     这种方式时将接口和继承相互组合，进行实现。
     
     缺点：需要开发这对继承和接口了解，扩大了程序复杂度。
##装饰者模式
    额外小知识：protected 关键字，对子类开放，对外部禁止
    代码：pattern.decorator.position
    装饰者模式和桥接模式有些相似，装饰者模式可以在不改变主体类的情况下，使用继承的方式进行纵向扩展
    要点：抽象装饰类，实现抽象类
        抽象具体类，装饰实现具体类
##外观模式
    代码：pattern.appearance
    通过一个整体，访问各个内部。感觉应用场景比较少
##享元模式
    pattern.flyweight????? 没搞懂！！！！
    
##组合模式
    代码：pattern.combination
    组合模式就是解决整体和细节之间的问题，比如：xx公司下有HR，财务，研发等部门，HR下面又划分了许多小组，
    小组下可以还会细分数小单元，部门下面又具体的人员，那么此时给职能不萌增加成员的时候，就会比较麻烦，此时
    就可以使用组合模式，抽象出一个构建，使用接口实现的方式，将细分出来的部门+成员进行组合
    
 ##模版方法模式
    代码：pattern.ternplateMethod
    如果在软件设计中，遇到一些相同的操作，我们可以使用模版方式模式的方法，将模版类抽象出来，在抽象类中固定
    执行顺序，将非共性的方法抽象出来，让子类自行实现，在次过程中，可以使用钩子的方法(重写父类方法)的方式，
    将父类中已经实现的方式重写，成为子类的特性。
##策略模式（重点）
    代码：pattern.strategy
    策略模式即为一个抽象的多种实现，在此基础上，可以加入单例模式中的懒汉模式实现策略工厂
##命令模式
    代码：pattern.command
    命令模式，将请求者与处理者分离，中间由指挥者接管，请求者只管发送指令，处理者只管处理，
    抽象出指令执行方法，并具体出执行方法，执行处理者方法
    执行者调用指令，下发指令，指令去执行处理者方法
##责链模式
    代码：pattern.responsibility
##观察者模式
    代码：pattern.watch
      抽象出主题，并具体主题，
      抽象接口通知，
      由具体实现这监听
##中介者模式
##迭代器模式
    代码：pattern.iteration.utils
    数据载体和迭代器相互隔离，用户遍历数据，通过统一的迭代器进行查看，
    接口之间相互隔离
    
   

