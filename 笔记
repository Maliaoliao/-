###从今天开始，每天学习一点点，从基础开始，每天学习一个设计模式，从原理上弄懂，运用到真实的业务常见中

####学习java设计模式来源与《软件设计模式java版》
[语法](https://www.runoob.com/markdown/md-tutorial.html)
   
   
   什么是设计模式？
   
   
    设计模式是前辈们为了解决开发过程中经常重复的场景，而设计的一整套开发模式。
    这样有利于提高代码的重复利用性，可读性，可维护性，稳健型，安全性。
   为什么要使用设计模式？
   
   
    1：提高程序开发者的思维，逻辑，设计能力。
    2：增加代码的可重复利用，可维护，可扩展，安全，稳健性能。
    3：提高代码质量
   
   怎么去用?
    
    啥地方
    
   关于设计模式的4大关键要素
   
    1.设计模式的名称是什么？
    2.解决了一个什么样的问题？
    3.具体的设计方案和思路？
    4.达到了一个什么样的效果？
    
   在学习设计模式之前，需要知道面向对象中的几个关键知识点。继承，封装，多态。以及面向对象中的设计原则
   
  
   设计原则：
   
   1.开闭原则。
   
        软件或者程序应当对扩展开放，对修改关闭。
        
        在企业开发环境中，面对需求的不断迭代变更，遵循开闭原则，让程序增加可扩展性，在每次变更内容的时候，
        将程序的颗粒度降低到最小，只需要在原有基础之上，扩展对应功能即可，提高代码高复用
        
   2.里氏替换原则。
       
        是对开闭原则的实现。使用继承时，必须保证父类拥有的全部性质在子类中仍然成立。
        
        例如：我们都知道自然界中有鸟类，大部分鸟儿都会飞，如果我们定义一个父类，父类中有飞行这个方法。然后我们
        又创建了两个子类，分别是麻雀类，鸵鸟类。但是我们同时去继承父类（鸟类）的时候，此时的鸵鸟因为不会飞翔，
        所以继承了父类的时候，就违反了里氏替换原则。
        
   3.依赖倒置原则
   
        高层模块不应该依赖低层模块，两者都应该依赖其抽象类，
        抽象类不应该依赖细节，细节应该依赖抽象
        
        例子：代码见dependencyInversion包下的
   4.单一原则
   
        一个类或者对象，规定只能包含它自己的性质，如果存在其它特性，这样就会使代码颗粒度变粗，从而影响代码的
        耦合性。所有，一个类就负责处理与之对应的逻辑。
   
   5.接口隔离原则
   
        对单一原则的具体实现，将接口的颗粒度变细，将同一个业务模块的不能处理逻辑进行拆分，在需要使用该需求的
        地方，分别实现其不同的接口即可
        
        例子：代码见interfaceIsolation包下的
   6.迪米特原则
   
        我给这个类的另外一个名称叫"不要和陌生人说话"，在设计程序的时候，如果类和类之间没有比较的联系或者关系，
        那么他们之间的联系可以通过第三方来关联。有点中介的意思
        
        例子：代码见dmitry包下的
        
   7.合成复用原则
        
        合成复用，如果要实现代码复用，首先要考虑合成/聚合，达到复用代码的效果，其次才是选择使用继承。
        
>总结：这7大原则是为了我们在开发过程中，提高代码的复用性，降低代码相互之间的耦合性，
      提高代码的可读性，可维护性，可扩展性。站在巨人的肩膀上我们可以看的更高，走的更远。
     




软件设计模式，是基于这7个开发原则的，遵循7大开发原则，可以使我们的代码`可读性`，`可维护性`，`可扩展性`。
那么就让我们开始学习软件设计模式吧。

[百度](http://baidu.com)

[变量命名](https://unbug.github.io/codelf/#%E7%9C%81%E4%BB%BD)
##单例模式
       
       单例模式是在软件开发过程中，为了避免资源重复的创建，保证数据的一致性对对象只创建一次。
       有点"办事只跑一趟的味道"

* 懒汉模式
       
       特点：当创建一个新的类的时候，我们只需要创建一次，在代码中可以判断该对象是否为空的方式来实现单例模式
       中的懒汉模式。
       
       应用场景：配置对象，数据连接池等

    ```
     public class Switch {
     
         private static volatile Switch witch = null;
         Switch(){
             System.out.println("内部方法");
         }
     
         public static synchronized Switch getSwitch(){
             //懒汉模式的体现，如果不为空的话会创建，为空的话就会返回已经创建好的对象
             if(witch == null){
                 System.out.println("空开关");
                 witch = new Switch();
                 return witch;
             }
             System.out.println("已经打开了");
             return witch;
         }
     
         public void getName(){
             System.out.println("这是一个开关");
         };
     }
      
       /**
       * Test 测试懒汉模式.
       */
      @Test
      public void testMethod() {
          Switch s = Switch.getSwitch();
          s.getName();
          Switch s2 = Switch.getSwitch();
          s2.getName();
          //如果使用new出来的对象,对象的code是不一样的。（通过debug的方式可以查看）
          Switch s3 = new Switch();
          if (s == s2) {
              System.out.println("同一个操作对象");
              return;
          }
          System.out.println("不同的操作对象");
      }
     ```
       

* 饿汉模式

        特点，在程序创建的时候，该对象就已经创建。
    ```
    public class User {
    
        /**
         * 对象在运行程序的时候就被创建出来了
         */
        private static User instance;
    
        static {
            instance = new User();
        }
        private User(){
            System.out.println("第N次进入");
        }
    
        /**
         * Get user user.
         *
         * @return the user
         */
        public static final User getUser(){
            System.out.println("进来");
            return instance;
        }
    
        /**
         * Gets name.
         */
        public void getName() {
            System.out.println("获取用户名称");
        }
    }
      //测试饿汉模式
      @Test
      public void test() {
          User u = User.getUser();
          u.getName();
  
          User u2 = User.getUser();
          u2.getName();
  
  
          if(u == u2){
              System.out.println("同一个对象");
          }
  
      }
  ```
        
##原型模式
        
        使用clone()实现对对象的克隆，这样产生的对象相对与单例模式产生的对象，它们的内存地址是不一样的。
        核心就是克隆对象,
        在对象属性相同或者相似的时候，可以克隆对象实现原型模式
    
```
    public class User implements Cloneable {
    
        /**
         * 对象在运行程序的时候就被创建出来了
         */
        private static User instance;
    
        static {
            instance = new User();
        }
        private User(){
            System.out.println("第N次进入");
        }
    
        /**
         * Get user user.
         *
         * @return the user
         */
        public static final User getUser(){
            System.out.println("进来");
            return instance;
        }
    
        /**
         * Gets name.
         */
        public void getName() {
            System.out.println("获取用户名称");
        }
    
    }
    
    @Test
        public void test() throws CloneNotSupportedException {
            User u = new User();
    
            User res = (User) u.clone();
    
            if(u == res){
                System.out.println("对象相等");
            }
    
    
            if(u == res){
                System.out.println("对象相等");
            }
            System.out.println(u.getName());
    
            System.out.println(res.getName());
    
        }
```
##工厂模式
        特点：创建与使用分离，使用者只需要关于工厂会产生的内容，而无需关注工厂的具体实现。
        代码：  factory
        一个字：妙
##建造者模式
        建造者模式
            1.抽象buile类，用来提供抽象的建造方法。
            2.抽象build实现类，用来实现具体的建造方式，包含具体的实现。
            3.指挥者类，用来协调构建buile创造类中的方法。
        代码：build
    
   
   

